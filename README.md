#### 编写React-TodoList案例

### 项目需求
实现如下页面并完成：
1. 用户输入任务后，敲击回车，在列表的首部添加任务，任务默认未完成；
2. 任务完成后可以勾选，被勾选的任务项文字颜色变浅，且底部已完成的数量跟随更新；
3. 鼠标移入任务卡，该任务高亮，且后面出现删除按钮；
4. 勾选底部全选按钮，所有任务完成，反之全不选；
5. 删除已完成任务，清除所有已完成任务。
   
<img src="./public/assets/images/todolist.png.png" alt="需求图片：参见public/images/todolist.png">

&emsp;
### 代码风格要求
1. 项目是组件化的，HTML、CSS、JS都在对应的组件上
2. 按需实现CSS的模块化
3. 不遗留交互的BUG，如：
      - 输入框内容为空时不允许添加任务
      - 任务添加完成输入框应该清空
      - 页面无任务时全选按钮不能在勾选状态
      - 删除任务时需用户二次确认等
      - 列表无任务卡时，展示无数据占位效果
4. 需要对组件Props做类型和必要性检查


&emsp;

### 参考资料
动态生成全球唯一的ID库
1. nanoid库 （【推荐】因为它小，且功能完整）

```
<!-- 安装 -->
yarn add nanoid 或 npm i nanoid

<!-- 引入 -->
import { nanoid } from 'nanoid'
<!-- 生成唯一的id -->
nanoid()
```

1. uuid库 （库比较大）

```
<!-- 安装 -->
yarn add uuid 或 npm i uuid

<!-- 引入 -->
import { v4 as uuidv4 } from 'uuid'
<!-- 生成唯一id -->
uuidv4()
```


&emsp;

### 编写步骤
1. **拆分组件、实现静态组件**
    - 注意：`className`和`style`的JSX写法，与原生不同，有原生衍生而来。

2. **动态初始化列表，如何确定将数据放在哪个组件的`state`中？**
    - 某个组件自己使用，放在其自身的`state`中;
    - 某些组件共同使用，放在他们共同的父组件中；（React官方称之为：**状态提升**）

    - 设计状态时，如有循环列表，应当提前关注使用数据时循环体`Key`的问题，设置唯一表示如`id`。这直接影响React虚拟DOM更新策略。

3. **动态组件的交互。React要求绑定事件需传入一个回调函数**
    - 无参数式事件绑定：可以直接用`onChange={this.handleChange}`(JSX)的方式传入回调函数
    - 有参数式事件绑定：使用高阶函数+柯里化方案，通过外层函数接收参数，并返回一个函数来实现React调用内层返回的回调函数，当然，`event`也在内层函数上
    - 有参数式事件绑定：除高阶函数方案外，还可以通过`onChange={() => this.handleChecked(selfParam)}`(JSX)的方式直接定义回调函数

4. **关于父子之间通信：**
   - 【父组件】给【子组件】传递数据，通过`props`传递
   - 【子组件】给【父组件】传递数据，通过`props`传递，要求父组件提前给子组件传递一个函数通过参数来接收该数据

5. **关于祖孙之间的通信：**
    - 【祖组件】给【孙组件】传递数据，可以借助【子组件】通过`props`传递。子组件在获取`props`时可以把自己要用的数据解构出来，而仅用于透传给孙组件的数据在解构折叠在`attr`（可自定义名称）里，通过React+Babel特殊支持的`{...attr}`语法一次性传给孙组件。即：`const {a, b, ...attr} = this.props` JSX里`<grand-son {...attr} />`
    - 在该场景中，【子组件】页面透传的props在【子组件】是不做格式及必要性检查的，而是由【孙组件检查】。如果在子组件检查了，那么孙组件就不用再检查了。不建议这么做。

6. **注意输入类控件`defaultChecked` 和 `checked` 的区别，**类似的还有`defaultValue` 和 `value`
   - `defaultChecked`只会在第一次执行，后续即便数据更新，也不会出发多选框选中或取消选中
   - 配置了`checked`，控件会随着数据变化而响应，也需要配置`onChange`(JSX)来处理变化事件

7. **状态在哪里，操作状态的方法就在哪里。**
   - 状态的增删改查，应当由状态所在的组件执行完成，子组件如需更新状态，可以通过`props`调用该组件的对应方法实现
   - 操作状态的方法应当只保留操作状态的功能代码。而限制条件、合法性检查，如是否允许调用等代码应当在对应子组件提前处理

8. **严格模式下,window下的变量前要加window.**
   - 如`window.confirm('二次确认提示信息')`，而非直接使用`confirm('二次确认提示信息')`

